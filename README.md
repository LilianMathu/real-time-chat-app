# Socket.io Chat App using AngularJS

1) ` bower install `

2) ` npm install `

Running on port: 8080

<br><br><br>
<h3>Chat Application</h3><br>
 <h3>Introduction</h3><br>
Hello, my name is Patrick Schroeder, and welcome back to Building Real-time Applications with Socket. io. So far you've learned the essentials of working with Socket. io, and built a few basic starter apps along the way. In this section, we'll build out a working chat application; we'll be using Angular version 1. 5 as our front-end framework of choice. Our chat application will include a login page where users are prompted to submit a username. Once inside the main page, users will be able to send messages that will be received by all connected users in real-time. Users will also be able to click a button to send likes to the user of their choice, and this will display a message to only the selected user. In addition to the files added to the lectures, you can also find the starter files along with the completed project in the GitHub repo.

 <h3>Starter Files Explained</h3><br>
For this project, I've provided you with a starting template that includes boilerplate code that can be found in the chat_before folder in the GitHub repo, and also included in the lecture downloads. So let's open up these files now and understand the structure. In our root folder we have a package. json file, and this includes our three node packages we'll need for this project. Our server. js file acts as the main entry point for our application. In here we have the same setup as before, first requiring in our modules, then locating our public folder, then initiating socket. io, and finally, listening for our server to start. I've included a bower. json file, and this will install all of our front-end libraries. We're adding a few Angular dependencies which will be discussed when we get to our Angular implementation, along with Bootstrap for styling, and Font Awesome so we can add in some icons. We have a bowerrc file here, and this will tell Bower where to install our declared dependencies. In this case, we'll be installing them in the bower_components folder inside of our public folder. So now let's inspect what's inside of our public folder. We'll start with the index. html file. This file serves as the main entry point to our front-end application. At the top here we add in our CSS files, then we make sure to Bootstrap our Angular application by declaring ng-app. Below that we create a navbar area that is shown on every page, and we insert ng-view here, which tells Angular to load our defined routes and partials. Next up we make sure to include socket. io file, just like we did in our previous set ups. And finally, we declare our Bower JavaScript files, along with our Angular JavaScript files. Let's now open up our app. js file. This file will serve as our Angular module loader for our five dependencies, as well as configuring our two routes. We'll have a join route and a main route, with their associated controllers, and I'd like to set html5Mode to true, which will remove the hash sign from our URL. I've included a join folder and a main folder, following the convention of separating out our application components by feature. These folders both contain an HTML file, as well as a controller file which we'll dig into as we build our app. Our css folder contains a style sheet with a few style declarations for our divs and body. We also have a components folder, which contains the skeleton of a socket factory we'll use to connect to our Socket. io client. And finally, we have a bower_components folder, which contains all of our front-end libraries. And now that we have a better understanding of our file structure, let's get to work building our chat application.

 <h3>Add Join Controller</h3><br>
Now that we've taken a look at our boilerplate files, I've renamed our folder to chat, to make it clear which project we're working on. I'm going to be using nodemon in this project, which will automatically restart our server any time changes are made to our server-side files. You can install nodemon globally by going into your terminal and using the command npm install -g, for global, followed by nodemon. And if you're on a Mac you may need to prefix npm install with the command sudo. Once nodemon is installed, navigate to the location of your project and type nodemon server. js to start the server. We'll navigate over to localhost:8080 and load up our app, which at this point just displays a non-functioning join page. To get started building our app, let's make this Join button work and take us into the main page. We'll open up our join. html file and inspect the contents. In here we're greeted with a form that has an ng-submit called join, and an ng-model called name. Let's now use these model and property declarations in our controller. To do so, we'll open up our join. Ctrl file. You'll notice that I've provided you with my preferred set up for creating controllers. 
<p>We start with an IIFE, or immediately invoked function, to create a container around our variables, we declare our module as app, and we give a name to our controller. Then I use $inject to inject the dependencies I intend to use. Inside of my join controller function I'm going to declare a few variables. We're using an ng-model called name to store the user's name in the form, so we'll set that equal to an empty string. I'm also going to declare a variable here called nickname to use below. Now let's create the join method declared in the template. To do this I'm going to set scope. join to a function, and inside the function I'm going to store a reference to scope. name to our nickname variable to be used later. I'm going to be using localStorage to store the name of our user, and after the user submits the form I'm going to send them to our main page by setting the location. path to main. With our join controller set, let's run the server now and see what we get. Now we're inside the main page, but it's still static, and our messaging isn't functional just yet. So the one simple thing that I want to do here is display our user's name next to this welcome message, so to do that let's open up our main. Ctrl file, and our main. html file. At the top of our main. html file, I've created a place for Angular data binding called mynickname. So flipping back into our main controller, I can do this by setting scope. mynickname to localStorage. nickname. We can now test this out in our app and see that the username gets displayed in the main page. And with our username set, let's start adding some Socket. io methods to display all of the connected users.</p>

 <h3>Join Event</h3><br>
At this point we've created a way to store our username locally, now let's see how we can connect that username to a socket, and then broadcast our username to all other connected users. If we open up our main. html file, there is an area here called Other Users, and this is where we'll be displaying the names of all other connected users. But before we get there, we need to create a socket service to handle the business logic of sending and receiving events through Socket. io. We'll be doing this in our socket. Srvc file, which is located in the components folder. So far I've created a skeleton similar to what's found in our controller file, and created a factory named socket. And we need to use rootScope here because Angular 1 does not intercept WebSocket data coming from the browser. I'll start by defining a socket variable, which is equal to the io. connect method, and this will open up Socket. io connections between the browser and the server. We're going to be adding two methods here called on and emit, they're going to be functions, so I need to return these as an object to make them public. The on method is going to listen for all incoming events for a given name, and then issue a callback performing some action. And then the emit method will send socket events out to our server to be received. 
<p>The method will include optional parameters including some data, as well as a callback. Now let's use our newly created service to emit our username in the join controller. So opening up the join. Ctrl file, I've already added the dependency for our socket factory right here. Within the join function I can say socket. emit, then declare my event name, which will be join, and include an object to be sent along. In this case I'm going to send back my nickname, which will end up being whatever the user has inputted in our join form. So let's now create the on method in the server. js file that will receive this emitted join event. So switching into my server file, the first thing that I'm going to do is create a user's variable that will store an array of users that have joined our chat. Inside the connection handler is where I will define my join event, so we'll say socket. on, our join event happens, then passing in a callback function, and I'm going to create a couple of log messages here so we can see what's going on in our terminal. Now I'm going to create a reference to my socket, and I can do this by saying socket., and then a variable name to reference, which I'm going to set to nickname, and this is going to equal data. nickname, so if a user joins with the name John, then this will be the socket name. Now in order to track the users, I need to set users of socket. nickname to the join socket, and this will become clear when we log out this user's object. Next, I'm going to create an object to be pushed into my users array that will contain my user's nickname, as well as a unique socket ID. So I'll create my user object, which has two properties, a nickname, which will be set to data. nickname, and a socket ID. So this socketid is something which is automatically created and attached to every new instance of a socket object. Then I'm going to push this object into my users array. And finally I'm going to emit a new event called all-users, and send with it my array of users. Notice that in this case we're using io. emit, instead of just socket. emit, and the reason is because we need to broadcast this event to all of our connected users. To understand the inner workings of our socket object a little better, let's add a few users and observe these logs.</p>

 <h3>Socket Object</h3><br>
I've opened up a couple of windows and navigated to port 8080, and have my server running. I'm going to create a couple of new users named me and me2. Now let's go back into our Node console to observe the output. Scrolling up to the top, you can see that we've logged out our data, which is nickname set to me and me2, and this represents our first console log declared here. And next we've logged an array of users. We're only seeing one user here since this log is declared before adding the user called me2, but we can see that the socket has been given a nickname that we declared as the user's name, which is me, and then we get this big object defining our socket, so if we scroll down little bit, we can see that there is an id key which is set to a unique string, and this is what we've defined as our socketid identifier in the object up above. Everything else below contains data that is used within the browser for handling WebSocket objects. Okay cool. Now we've seen the actual contents of our socket object, let's now see how to display all our connected users within our main page.

 <h3>Show All Users</h3><br>
We can display all the users that have joined by using a socket. on event listener in our main controller. So opening up our main controller file, I first add a reference to our users that we're going to display as an empty array, and I'm also going to create a variable reference for the mynickname property to be used below. To listen for our all-users event, I can say socket. on, passing in all-users, and a callback function containing the data I'm getting back from the server. I'll create a log message here, and now I want to filter for the other users, so I'll set my user scope to filter the data, and then return the users that are not equal to our newly joined user's nickname. And now we're ready to test out our new event handler. I'll open up two new windows here, and log in first as me, and then as me2. So when adding two new users, you can see that it's working when a new user joins, so that's pretty sweet, but we're not seeing the original user show up in our new user's column. What's happening here is the server is firing the all-users event before it's getting registered in the client. So one way to fix this is to emit an event at the top of our controller to get all of our users. So we'll say socket. emit, and our event will be called get-users, and we're not passing in anything, we're just triggering the event. So let's now flip over to our server. js file and create our corresponding event. So when the server would listen for the event by saying socket. on, passing in get-users, as well as a function that will then emit the event all-users, and passing along our users array. Also notice that in this instance we're using the socket. emit, since we don't want to broadcast to all listeners, but only to the socket that made the initial request. So let's test this out one more time. And look, now we're getting all the other users populated into our view automatically when we join as a new user. Okay great, we've made some nice progress, now let's get into the meat of our chat application and set up our messaging.

 <h3>Send Messages</h3><br>
We're now ready to set up our messaging feature. The only new concept in this section will be how to broadcast our messages to all connected listeners. Let's start out by opening up our main. html file, and about halfway down we see a column that includes a form with a sendMessage function, and we're also binding to a message property here. Then below, we're going to loop through and display all the messages that have been sent and received inside this well area here. Now we'll open up the main controller file, and start by defining an initial state for our message, which will be an empty string, and also a variable for all of the messages, which will be an array. Let's now define our send message function. I'm going to send along an object with my emit event, so I'll declare my object right here, which will contain the message itself, along with who sent the message. Now let's go ahead and add the socket event, which will emit an event called send-message, and also pass along the object that we just defined. Then we'll go ahead and clear the message from our form, and then push this message into the view. Let's now switch over to our server file and create our corresponding event. So we'll say socket. on, then declare our send-message event, along with the function that has a data parameter that holds the object that we received. And now we're going to broadcast, or send back to all connected users our message object, and to do this we'll say socket. broadcast. emit, and then name our event, which will be called message-received, and then pass along the data. The socket. broadcast method is going to pass the data to everyone except the socket that sent the event. And since we're emitting a new event, we naturally need a corresponding on event to pick it up. So switching back into our main controller, we'll create this message event right here, and we're just using the data we received back from the server, and pushing it into our messages array. So let's now fire up our app and see our messaging system in action. Okay great, it's working. We're seeing instant messaging broadcast among all connected clients. Now we do have one alternative when broadcasting messages. Instead of limiting our messages to all other users, we can include ourself. So just like how we're using io. emit up above, we can use it in place of socket. broadcast. So if instead we say io. emit, sending over the same event and message, then in the controller we won't need to push our message to the view after sending. So we can simply comment out this line, restart our app, and the app is going to work in just the same way.

 <h3>Send Private Likes</h3><br>
We're making great progress with our app. Let's take the next step and learn how to isolate our messages to the user of our choice. In our app, next to every user is a thumbs up icon. When clicking on this icon, I want only that user to receive a special message. So let's first open up our HTML file, here is where we're displaying the other users, and next to the user's name we have our icon, with a click event called sendLike, then below that is where we're displaying our likes column, and this includes a thumbs up icon, the name of the user who sent the like, and a text message. Switching now into our main controller, I'll first create an empty array to store the likes. Now let's create our sendLike function. So we'll start with scope. sendLike equals a function that accepts a parameter that represents the user object that I want to like. This user is an object that has a nickname, as well as a unique socket ID. Remember, we defined this object right here when the user first joined. I'm going to add a log message here to print out our user, and I still need to create a reference to just the socket ID of the user, so I'll make a variable for the user's ID, and then I'm going to use the super handy get method from lodash, passing in the user object, and then declaring which key I want to grab. Then I'm going to make an object to send out to our server, which is going to contain the nickname of the user who sent the like, along with this ID representing who we want to send the like to. Then we'll emit an event called send-like, containing our object, and to make this a little more clear, let's open up our browser and output this log message. So you can see when clicking on another user's like button, we get their object and then we're grabbing this socketid in our ID variable. So with that set up, let's now wire up our back-end event. Opening up our server file, we'll start by creating a corresponding socket event which is named send-like, and then of course passing along a function that contains the data that we received. And we'll go ahead and log out that data to our console. Now we want to send part of this data to a specific socket, and we can do this using the to method. So we'll say socket. broadcast. to, and then specify our socket ID, which is data. like. So now we're specifying who we want to send the data to, but we still have to actually send them the data, and socket. io again makes this very easy because we can chain along an emit method, and then create our event name, which we'll set to user-liked, passing along the same data object, then all we need to do is create this corresponding event in our controller. So we'll say socket. on, passing in our newly created user-liked event, along with the function containing our data. So we'll go ahead and log out the data, and then push to our likes array data. from, again representing the user that sent the like, and now we can test this out. And you can see everything works as expected. Also, make sure to observe the logs in both our browser and Node console if you're confused by any of the code.

 <h3>Disconnect</h3><br>
Along with a connection event, Socket. io also provides us with a disconnect event, so right now, if a user closes their browser window, it's not going to register that this user has left our app. So let's fix that now by taking advantage of the disconnect event trigger. In my server file I'm going to create a new socket event that will listen for any socket disconnections, and in order to remove the disconnected user I just need to filter out the user from my users array, and then I can emit my all-users event to all sockets, and pass along the newly formed users array. Let's test this out by creating some new users, and then we'll remove a couple, and now we can see how everything gets updated correctly.

 <h3>Socket Join Method</h3><br>
We've been able to build a neat little chat application using just a few methods. Now there's just one other method that I want to show you, and that is the join method. When using the join method, we're able to subscribe our socket to a given channel, so within our on event, we can create a namespace for that socket, and in this case we've named it private. By using this method, we can form group chat and private rooms. In order to demonstrate how this works, I'm just going to create a few buttons with click events. So at the bottom of our main. html file, I've added a button that when clicked, will have our user join a private room, and then below that we'll have a button that when clicked will emit a message to only those users that have joined the private room. Moving over to our main controller, I'll start off by defining the logic for our joinPrivate function, and when the button is clicked we'll be joining a private socket and sending along our user's nickname. And we'll just log a message here, private room joined. Now let's go ahead and add the corresponding on event in our server. So we'll say socket. on, name our event join-private, and then pass a function containing the data. And here is where we'll have our socket join a room, which we'll name as private. I'll also add a log message here to show in our terminal. 
<p>Now we'll go back into our controller and create the function for our other click event called groupPm. When a user clicks on this button, we'll emit an event called private-chat, and we'll pass along the message hello everybody, to be seen by any other socket that has also joined. Then in the server we'll set up our socket. on private-chat, passing along a function containing the message, and then we can broadcast the message to all users using the broadcast. to method, then just pass in the name of the room that we set up right here. We can chain our emit event to send back to our view an event that we'll name show-message, and of course include the data object that contains our message. Switching now back into our controller, we can then show off the message by registering our show-message event, and in this case I'm just going to log the message out to our console. Now that we've got everything set up, let's see how this works in our browser. First I'll join three new users to our chat, then I'm going to join this private chat with just the me and me1 user, then I can click on the Send Group PM button, and only user me1 is going to receive the message. And we can see in this case by opening up the console in me2 and seeing that there is no message being displayed.</p>

 <h3>Summary</h3><br>
In this module we built a functioning chat application, and in the process covered the most commonly used methods within Socket. io. We started with the on and emit methods that act as a communication hub between the client and the server. We then added the broadcast method, which acts to send our data to all connected clients. Then, we looked at how to send events to specific sockets by using the to method. After that we discussed how to use the join method to create namespaces for our sockets. And finally, we used the disconnect event to help us listen for socket disconnections, and to update our users array accordingly.

 <h3>Course Summary</h3><br>
In this course we covered the most important features, benefits, and uses of Socket. io. I really enjoyed putting this course together, and I hope you feel like you're a better developer for taking the time to view it. Remember that the uses for Socket. io are certainly not limited to chat, but can be integrated with many other real-time applications and database structures. Please know that I am available to answer any questions you have in the discussion area. Thank you so much for watching, and I'll see you in the next one.
